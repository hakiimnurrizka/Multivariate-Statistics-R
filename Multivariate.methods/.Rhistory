identify_outliers(y1)
#delete the extreme outliers
survtime2 = survtime[-c(32,51),]
survtime2 %>%
group_by(type) %>%
identify_outliers(y1)
library(ggpubr)
#we'll start from analyzing data in univariate then computing the test statistics and
#lastly checking for assumption violation
ggboxplot(survtime, x = "type", y = "y1", add = "point")
lmsurv_y1 = anova_test(y1 ~ type*gender, data = survtime)
get_anova_table(lmsurv_y1)
survtime %>%
group_by(type, gender) %>%
identify_outliers(y1)
#delete the extreme outliers
survtime2 = survtime[-c(32),]
survtime2 %>%
group_by(type) %>%
identify_outliers(y1)
#delete the extreme outliers
survtime2 = survtime[-c(32, 51),]
survtime2 %>%
group_by(type) %>%
identify_outliers(y1)
#delete the extreme outliers
survtime2 = survtime[-c(32),]
survtime2 %>%
group_by(type, gender) %>%
identify_outliers(y1)
lmsurv_y1 = anova_test(y1 ~ type*gender, data = survtime2)
get_anova_table(lmsurv_y1)
lmsurv_y1 = anova_test(y1 ~ type+gender, data = survtime)
get_anova_table(lmsurv_y1)
lmsurv_y1 = anova_test(y1 ~ type, data = survtime2)
get_anova_table(lmsurv_y1)
survtime2 %>%
group_by(type) %>%
shapiro_test(y1)
get_anova_table(lmsurv_y1) #final result finds that only the type of cancer has different value of y1
lmsurv_y1 = anova(y1 ~ type, data = survtime2)
lmsurv_y1 = aov(y1 ~ type, data = survtime2)
get_anova_table(lmsurv_y1) #final result finds that only the type of cancer has different value of y1
lmsurv_y1 = anova_test(y1 ~ type, data = survtime2)
get_anova_table(lmsurv_y1) #final result finds that only the type of cancer has different value of y1
get_anova_table(lmsurv_y1) #final result finds that only the type of cancer has different value of y1
aov(y1 ~ type, data = survtime2)
summary(aov(y1 ~ type, data = survtime2))
anova(lm(y1 ~ type, data = survtime2))
shapiro_test(lm(y1 ~ type, data = survtime2)$residuals)
#delete the extreme outlier(s)
survtime2 = survtime[-c(32, 51),]
survtime2 %>%
group_by(type, gender) %>%
identify_outliers(y1)
lmsurv_y1 = anova_test(y1 ~ type*gender, data = survtime2)
get_anova_table(lmsurv_y1) #interaction is not significant, ignore the term
lmsurv_y1 = anova_test(y1 ~ type+gender, data = survtime2)
get_anova_table(lmsurv_y1) #gender is not significant
lmsurv_y1 = anova_test(y1 ~ type, data = survtime2)
get_anova_table(lmsurv_y1) #final result finds that only the type of cancer has different value of y1
shapiro_test(lm(y1 ~ type, data = survtime2)$residuals)
ggboxplot(survtime, x = "gender", y = "y1", add = "point")
#y2
ggboxplot(survtime, x = "type", y = "y2", add = "point")
ggboxplot(survtime, x = "gender", y = "y2", add = "point")
survtime %>%
group_by(type, gender) %>%
identify_outliers(y2)
survtime %>%
group_by(type) %>%
identify_outliers(y2)
#delete the extreme outlier(s)
survtime2 = survtime[-c(27),]
lmsurv_y2 = anova_test(y2 ~ type*gender, data = survtime2)
get_anova_table(lmsurv_y2) #interaction is not significant, ignore the term
lmsurv_y2 = anova_test(y2 ~ type+gender, data = survtime2)
get_anova_table(lmsurv_y2) #gender is not significant
lmsurv_y2 = anova_test(y2 ~ type, data = survtime2)
get_anova_table(lmsurv_y2) #final result finds that only the type of cancer has different value of y1
shapiro_test(lm(y2 ~ type, data = survtime2)$residuals)
#y3
ggboxplot(survtime, x = "type", y = "y3", add = "point")
ggboxplot(survtime, x = "gender", y = "y3", add = "point")
survtime %>%
group_by(type, gender) %>%
identify_outliers(y3)
#delete the extreme outlier(s)
survtime2 = survtime[-c(32),]
lmsurv_y2 = anova_test(y2 ~ type*gender, data = survtime2)
get_anova_table(lmsurv_y2) #interaction is not significant, ignore the term
lmsurv_y2 = anova_test(y2 ~ type+gender, data = survtime2)
get_anova_table(lmsurv_y2) #gender is not significant
lmsurv_y2 = anova_test(y2 ~ type, data = survtime2)
get_anova_table(lmsurv_y2) #final result finds that only the type of cancer has different value of y1
lmsurv_y3 = anova_test(y3 ~ type*gender, data = survtime2)
get_anova_table(lmsurv_y3) #interaction is not significant, ignore the term
lmsurv_y3 = anova_test(y3 ~ type+gender, data = survtime2)
get_anova_table(lmsurv_y3) #gender is not significant
lmsurv_y3 = anova_test(y3 ~ type, data = survtime2)
get_anova_table(lmsurv_y3) #final result finds that only the type of cancer has different value of y1
#y4
ggboxplot(survtime, x = "type", y = "y4", add = "point")
ggboxplot(survtime, x = "gender", y = "y4", add = "point")
survtime %>%
group_by(type, gender) %>%
identify_outliers(y4)
lmsurv_y4 = anova_test(y4 ~ type*gender, data = survtime2)
get_anova_table(lmsurv_y4) #interaction is not significant, ignore the term
lmsurv_y4 = anova_test(y4 ~ type+gender, data = survtime2)
get_anova_table(lmsurv_y4) #gender is not significant
lmsurv_y4 = anova_test(y4 ~ type, data = survtime2)
get_anova_table(lmsurv_y4) #final result finds that there is no difference between any type of group in regard of y3 value
#y3
ggboxplot(survtime, x = "type", y = "y3", add = "point")
#y2
ggboxplot(survtime, x = "type", y = "y2", add = "point")
#y1
ggboxplot(survtime, x = "type", y = "y1", add = "point")
#the univariate case finds that difference between type of cancer group happens
#in regard of variable y1 and y2
#a post-hoc analysis can be done for these 2 significant variables
#for simplicity we'll show the computation in post-hoc analysis for only y1
#and obviously post-hoc analysis for y2 can be done in a similar manner
survtime %>%
pairwise_t_test(y1 ~ type, paired = TRUE, p.adjust.method = "bonferroni")
#the univariate case finds that difference between type of cancer group happens
#in regard of variable y1 and y2
#a post-hoc analysis can be done for these 2 significant variables
#for simplicity we'll show the computation in post-hoc analysis for only y1
#and obviously post-hoc analysis for y2 can be done in a similar manner
survtime %>%
pairwise_t_test(y1 ~ type, p.adjust.method = "bonferroni")
#the univariate case finds that difference between type of cancer group happens
#in regard of variable y1 and y2
#a post-hoc analysis can be done for these 2 significant variables
#for simplicity we'll show the computation in post-hoc analysis for only y1
#and obviously post-hoc analysis for y2 can be done in a similar manner
survtime %>%
pairwise_t_test(y1 ~ type, p.adjust.method = "bonferroni")
library(readxl)
client_train <- read_excel("G:/My Drive/Github/Machine-Learning/client-data.xlsx",
sheet = "client_train")
View(client_train)
client_train =client_train[,-c(3:12)]
client_train1 = client_train[rowSums(client_train[,3:14])>0,] #training data that is not all zeros in bill and pay_amt
client_train2 = client_train[rowSums(client_train[,3:14])=0,]
client_train2 = client_train[rowSums(client_train[,3:14])==0,]
View(client_train2)
client_train2 = client_train[rowSums(client_train[,3:14])<=0,]
client_train2 = client_train[rowSums(client_train[,3:14])<0,]
client_train2 = client_train[rowSums(client_train[,3:14])==0,]
client_train1 = client_train[rowSums(client_train[,3:14])=/=0,] #training data that is not all zeros in bill and pay_amt
client_train1 = client_train[rowSums(client_train[,3:14])/=0,] #training data that is not all zeros in bill and pay_amt
client_train1 = client_train[rowSums(client_train[,3:14])=/0,] #training data that is not all zeros in bill and pay_amt
client_train1 = client_train[rowSums(client_train[,3:14])!=0,] #training data that is not all zeros in bill and pay_amt
View(client_train1)
View(client_train2)
library(factoextra)
### PCA ###
pca_train1 = prcomp(client_train1, scale = TRUE)
pca_train1$rotation
library(readxl)
client_train <- read_excel("G:/My Drive/Github/Machine-Learning/client-data.xlsx",
sheet = "client_train")
View(client_train)
client_train = client_train[,-c(1,3:12)]
View(client_train)
client_train1 = client_train[rowSums(client_train[,3:14])!=0,] #training data that is not all zeros in bill and pay_amt
client_train2 = client_train[rowSums(client_train[,3:14])==0,]
client_train1 = client_train[rowSums(client_train[,2:13])!=0,] #training data that is not all zeros in bill and pay_amt
client_train2 = client_train[rowSums(client_train[,2:13])==0,]
### PCA ###
pca_train1 = prcomp(client_train1, scale = TRUE)
pca_train1$rotation
pca_train1$x
head(pca_train1$x,10)
head(pca_train1$x,7)
head(pca_train1$x,7)
fviz_eig(pca_train1)
fviz_eig(pca_train1)
summary(pca_train1)
fviz_pca_ind(pca_train1,
col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
fviz_pca_var(res.pca, col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE
# Avoid text overlapping
)
fviz_pca_var(pca_train1, col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE
# Avoid text overlapping
)
### PCA ###
pca_train1 = prcomp(client_train1[,1:13], scale = TRUE)
head(pca_train1$x,7)
fviz_eig(pca_train1)
summary(pca_train1)
fviz_pca_ind(pca_train1, col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
fviz_pca_var(pca_train1, col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE
# Avoid text overlapping
)
fviz_pca_ind(pca_train1, col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = T)
library(readxl)
client_train <- read_excel("G:/My Drive/Github/Machine-Learning/client-data.xlsx",
sheet = "client_train", col_types = c("skip",
"numeric", "text", "text", "text",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric"))
View(client_train)
client_train1 = client_train[,-c(1:11)]
client_train1 = client_train[rowSums(client_train[,1:12])!=0,] #training data that is not all zeros in bill and pay_amt
str(client_train1)
client_train1 = client_train1[rowSums(client_train[,1:12])!=0,] #training data that is not all zeros in bill and pay_amt
client_train1 = client_train1[rowSums(client_train1[,1:12])!=0,] #training data that is not all zeros in bill and pay_amt
### PCA ###
pca_train1 = prcomp(client_train1[,1:13], scale = TRUE)
head(pca_train1$x,7)
### PCA ###
pca_train1 = prcomp(client_train1[,-13], scale = TRUE)
head(pca_train1$x,7)
fviz_eig(pca_train1)
summary(pca_train1)
view(head(pca_train1$x,7))
View(head(pca_train1$x,7))
fviz_pca_ind(pca_train1, col.ind = "cos2", # Color by the quality of representation
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = T)
fviz_pca_var(pca_train1, col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
fviz_pca_var(pca_train1, col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
fviz_pca_var(pca_train1, col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
library(readxl)
client_test <- read_excel("G:/My Drive/Github/Machine-Learning/client-data.xlsx",
sheet = "client_test")
View(client_test)
client_test.PC = predict(pca_train1, newdata = client_test)
client_test.PC
client_test.PC = predict(pca_train1, newdata = client_test[,13:24])
client_test.PC
client_test1 = as.data.frame(cbind(client_test[,-1],client_test.PC[,1:2]))
View(client_test1)
client_test1 = as.data.frame(cbind(client_test[,-c(1,13:24)],client_test.PC[,1:2]))
View(client_test1)
client_train1 = client_train[,-c(1:11)]
### PCA ###
pca_train1 = prcomp(client_train1[,-13], scale = TRUE)
View(head(pca_train1$x,7))
fviz_eig(pca_train1)
summary(pca_train1)
fviz_pca_var(pca_train1, col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE)
client_test.PC = predict(pca_train1, newdata = client_test[,13:24])
client_test1 = as.data.frame(cbind(client_test[,-c(1,13:24)],client_test.PC[,1:2]))
View(client_train)
## Building the logistic regression for predictive study
client_train_new = as.data.frame(cbind(client_train[,1:11],pca_train1$x[,1:2]))
View(client_train_new)
## Building the logistic regression for predictive study
client_train_new = as.data.frame(cbind(client_train[,-c(12:23)],pca_train1$x[,1:2]))
View(client_train_new)
client_log = glm(default.payment.next.month~., data = client_train_new, family = binomial)
summary(client_log)
client_train_new[,6] = as.factor(client_train_new[,6])
client_train_new[,2] = as.factor(client_train_new[,2])
client_train_new[,3] = as.factor(client_train_new[,3])
client_train_new[,4] = as.factor(client_train_new[,4])
client_train_new[,6] = as.factor(client_train_new[,6])
client_train_new[,7] = as.factor(client_train_new[,7])
client_train_new[,8] = as.factor(client_train_new[,8])
client_train_new[,9] = as.factor(client_train_new[,9])
client_train_new[,10] = as.factor(client_train_new[,10])
client_train_new[,11] = as.factor(client_train_new[,11])
client_log = glm(default.payment.next.month~., data = client_train_new, family = binomial)
summary(client_log)
View(client_train_new)
View(client_train)
## Building the logistic regression for predictive study
client_train_new = as.data.frame(cbind(client_train[,-c(6:23)],pca_train1$x[,1:2]))
View(client_train_new)
client_train_new[,2] = as.factor(client_train_new[,2])
client_train_new[,3] = as.factor(client_train_new[,3])
client_train_new[,4] = as.factor(client_train_new[,4])
client_log = glm(default.payment.next.month~., data = client_train_new, family = binomial)
summary(client_log)
client_log = glm(default.payment.next.month~0+., data = client_train_new, family = binomial)
summary(client_log)
client_log = glm(default.payment.next.month~0+LIMIT_BAL+EDUCATION+MARRIAGE+PC1+PC2, data = client_train_new, family = binomial)
summary(client_log)
#predict
predict(client_log, newdata = client_test1)
#predict
predict_client_stat = predict(client_log, newdata = client_test1)
View(client_test1)
#predict
predict_client_stat = predict(client_log, newdata = client_test1[,c(1,3,4,13,14)])
client_test1[,c(1,3,4,13,14)]
#predict
predict_client_stat = predict(client_log, newdata = client_test1[,c(1,3,4,12,13)])
#predict
predict_client_stat = predict(client_log, newdata = client_test1[,c(1,3,4,12,13)], type = "response")
library(ggplot2)
# Using specificity and sensitivity to decide the response threshold
sens = data.frame(x=unlist(performance(predictions, "sens")@x.values),
y=unlist(performance(predictions, "sens")@y.values))
library(performance)
# Using specificity and sensitivity to decide the response threshold
sens = data.frame(x=unlist(performance(predict_client_stat, "sens")@x.values),
y=unlist(performance(predict_client_stat, "sens")@y.values))
View(client_train1)
View(client_train_new)
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,12,13)], type = "response")
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
# Using specificity and sensitivity to decide the response threshold
sens = data.frame(x=unlist(performance(predict_client_stat, "sens"),client_test1[,c(1,3,4,7,8)]),
y=unlist(performance(predict_client_stat, "sens"),client_train_new[,c(1,3,4,7,8)]))
performance(predict_client_stat, "sens")
# Using specificity and sensitivity to decide the response threshold
sens = data.frame(x=unlist(performance(predict_client_stat, "sens")@client_test1[,c(1,3,4,7,8)]),
y=unlist(performance(predict_client_stat, "sens")@client_train_new[,6]))
performance(predict_client_stat)
performance(client_log)
performance_accuracy(client_log)
performance_accuracy(client_log)@client_train_new[,c(1,3,4,7,8)]
performance_accuracy(client_log)@client_train_new
performance_accuracy(client_log)
library(caret)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
predict_client_stat = ifelse(predict_client_stat>0.5,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
predict_client_stat = ifelse(predict_client_stat>0.4,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
predict_client_stat = ifelse(predict_client_stat>0.3,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
predict_client_stat = ifelse(predict_client_stat>0.6,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
predict_client_stat = ifelse(predict_client_stat>0.9,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
head(predict_client_stat)
head(predict_client_stat, 100)
predict_client_stat = ifelse(predict_client_stat>0.0.99,1,0)
predict_client_stat = ifelse(predict_client_stat>0.99,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
head(predict_client_stat)
head(predict_client_stat, 100)
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.9,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.4,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.3,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.35,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
# Using specificity and sensitivity to decide the response threshold
sens = data.frame(x=unlist(performance(predict_client_stat, "sens")@client_train_new[,c(1,3,4,7,8)]),
y=unlist(performance(predict_client_stat, "sens")@client_train_new[,6]))
# Using specificity and sensitivity to decide the response threshold
sens = data.frame(x=unlist(performance(client_log, "sens")@client_train_new[,c(1,3,4,7,8)]),
y=unlist(performance(client_log, "sens")@client_train_new[,6]))
specificity(conf_mat_client)
sensitivity(conf_mat_client)
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.4,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
specificity(conf_mat_client)
sensitivity(conf_mat_client)
conf_mat_client
summary(client_log)
client_train_new[,6] = as.factor(client_train_new[,6])
client_log = glm(default.payment.next.month~0+LIMIT_BAL+EDUCATION+MARRIAGE+PC1+PC2, data = client_train_new, family = binomial)
summary(client_log)
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.5,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
specificity(conf_mat_client)
sensitivity(conf_mat_client)
conf_mat_client
predict_client_stat = ifelse(predict_client_stat>0.3,1,0)
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.3,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
specificity(conf_mat_client)
sensitivity(conf_mat_client)
conf_mat_client
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.25,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
specificity(conf_mat_client)
sensitivity(conf_mat_client)
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.35,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
specificity(conf_mat_client)
sensitivity(conf_mat_client)
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
install.packages("ROCR")
library(ROCR)
predictions = prediction(predict_client_stat, client_train_new$default.payment.next.month)
sens = data.frame(x=unlist(performance(predictions, "sens")@client_train_new[,c(1,3,4,7,8)]),
y=unlist(performance(predictions, "sens")@client_train_new[,6]))
performance_accuracy(predictions)
performance(predictions)
performance(predictions)@client_train_new[1,3,4,7,8]
summary(predictions)
performance(predictions,"sens")@client_train_new[1,3,4,7,8]
performance(predictions,"sens")@x.values
sens = data.frame(x=unlist(performance(predictions, "sens")@x.values),
y=unlist(performance(predictions, "sens")@y.values))
spec = data.frame(x=unlist(performance(predictions, "spec")@x.values),
y=unlist(performance(predictions, "spec")@y.values))
sens %>% ggplot(aes(x,y)) +
geom_line() +
geom_line(data=spec, aes(x,y,col="red")) +
scale_y_continuous(sec.axis = sec_axis(~., name = "Specificity")) +
labs(x='Cutoff', y="Sensitivity") +
theme(axis.title.y.right = element_text(colour = "red"), legend.position="none")
library(dplyr)
sens %>% ggplot(aes(x,y)) +
geom_line() +
geom_line(data=spec, aes(x,y,col="red")) +
scale_y_continuous(sec.axis = sec_axis(~., name = "Specificity")) +
labs(x='Cutoff', y="Sensitivity") +
theme(axis.title.y.right = element_text(colour = "red"), legend.position="none")
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
predict_client_stat = ifelse(predict_client_stat>0.6,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
specificity(conf_mat_client)
sensitivity(conf_mat_client)
conf_mat_client
# predict
predict_client_stat = predict(client_log, newdata = client_train_new[,c(1,3,4,7,8)], type = "response")
# Using specificity and sensitivity to decide the response threshold
predictions = prediction(predict_client_stat, client_train_new$default.payment.next.month)
summary(predictions)
sens = data.frame(x=unlist(performance(predictions, "sens")@x.values),
y=unlist(performance(predictions, "sens")@y.values))
spec = data.frame(x=unlist(performance(predictions, "spec")@x.values),
y=unlist(performance(predictions, "spec")@y.values))
sens %>% ggplot(aes(x,y)) +
geom_line() +
geom_line(data=spec, aes(x,y,col="red")) +
scale_y_continuous(sec.axis = sec_axis(~., name = "Specificity")) +
labs(x='Cutoff', y="Sensitivity") +
theme(axis.title.y.right = element_text(colour = "red"), legend.position="none")
#get the optimum threshold
sens = cbind(unlist(performance(predictions, "sens")@x.values), unlist(performance(predictions, "sens")@y.values))
spec = cbind(unlist(performance(predictions, "spec")@x.values), unlist(performance(predictions, "spec")@y.values))
sens[which.min(apply(sens, 1, function(x) min(colSums(abs(t(spec) - x))))), 1]
cutoff_opt_client = sens[which.min(apply(sens, 1, function(x) min(colSums(abs(t(spec) - x))))), 1]
#confusion matrix
predict_client_stat = ifelse(predict_client_stat>0.cutoff_opt_client,1,0)
#confusion matrix
predict_client_stat = ifelse(predict_client_stat>cutoff_opt_client,1,0)
conf_mat_client = table(predict_client_stat, client_train_new$default.payment.next.month)
conf_mat_client
specificity(conf_mat_client)
sensitivity(conf_mat_client)
View(client_test1)
#Apply model and cutoff on test data
predict_client_test = predict(client_log, newdata = client_test1[,c(1,3,4,12,13)], type = "response")
head(predict_client_stat, 100)
client_test1$predict.payment = predict_client_test
view(head(client_test1, 100))
View(head(client_test1, 100))
View(head(client_test1[,-c(2, 5:11)], 100))
#Apply model and cutoff on test data
predict_client_test = ifelse(predict(client_log, newdata = client_test1[,c(1,3,4,12,13)], type = "response")>cutoff_opt_client,1,0)
client_test1$predict.payment = predict_client_test
View(head(client_test1[,-c(2, 5:11)], 100))
